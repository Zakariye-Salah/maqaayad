<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin Dashboard - afro daafi and pizza</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    /* small admin page styles */
    body { background:#f6f7fb; font-family: Arial, sans-serif; }
    .admin-wrap { max-width:1100px; margin:24px auto; padding:12px; }
    .admin-row { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    .card { background:#fff; border:1px solid #eee; padding:12px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.03); }
    #ordersList .order { border-bottom:1px solid #f0f0f0; padding:12px 0; }
    .status-pill { padding:6px 8px; border-radius:6px; font-weight:600; font-size:13px; }
    .status-pending { background:#fff3cd; color:#8a6d1b; }
    .status-confirmed { background:#d4edda; color:#155724; }
    .status-denied { background:#f8d7da; color:#721c24; }
    .status-delivered { background:#cce5ff; color:#0b3d91; }
    .btn-small { padding:6px 8px; border-radius:6px; margin-right:6px; cursor:pointer; border:1px solid #ddd; background:#fafafa; }
    .search-input { padding:8px; width:280px; border-radius:6px; border:1px solid #ddd; }
    .filters { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .profile-box { margin-left:auto; }
    .hidden { display:none; }

    /* period totals */
    .totals-row { display:flex; gap:12px; margin-top:12px; align-items:center; flex-wrap:wrap; }
    .tot-card { padding:10px 12px; border-radius:8px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,0.04); border:1px solid #eee; min-width:160px; }
    .tot-card h4 { margin:0 0 6px 0; font-size:14px; color:#444; }
    .tot-card p { margin:0; font-weight:700; font-size:18px; }

    /* order view modal */
    .modal-backdrop { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:9999; }
    .modal { width:90%; max-width:720px; background:#fff; border-radius:8px; overflow:hidden; }
    .modal-header { padding:12px 16px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between; }
    .modal-body { padding:16px; max-height:70vh; overflow:auto; }
    .modal-footer { padding:12px 16px; border-top:1px solid #eee; text-align:right; }
    .order-items { margin:8px 0; }
    .order-items li { margin-bottom:6px; }

    #periodTotals .tot-card:nth-child(1) { background:#eef2ff; color:#1e3a8a; }
#periodTotals .tot-card:nth-child(2) { background:#ecfdf5; color:#065f46; }
#periodTotals .tot-card:nth-child(3) { background:#e0f2fe; color:#075985; }
#periodTotals .tot-card:nth-child(4) { background:#fff7ed; color:#9a3412; }

#periodTotals .tot-card p {
  font-size:22px;
}

/* Responsive admin profile fixes (mobile-first improvements) */
@media (max-width: 992px) {
  .admin-wrap { padding: 10px; }

  /* make the admin card area wrap cleanly */
  .admin-row > .card { width: 100%; }

  /* Ensure the filters area stacks on smaller screens */
  .admin-row > .card > div { flex-direction: column; align-items: stretch; gap: 10px; }

  /* Profile box: full width, visually separated and placed first */
  #adminProfileBox {
    order: -1;                /* place it first within the flex row on small screens */
    width: 100% !important;
    margin-left: 0 !important;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    box-sizing: border-box;
    padding: 10px;
  }

  /* Admin info block inside profile-box */
  #adminProfileBox #adminInfo {
    flex: 1 1 auto;
    min-width: 0;
    line-height: 1.2;
    word-break: break-word;
  }

  /* Ensure actions group lays out nicely */
  #adminProfileBox .profile-actions {
    display: flex;
    gap: 8px;
    align-items: center;
    flex: 0 0 auto;
  }

  /* Smaller screens: stack actions vertically and make buttons full width */
  @media (max-width: 480px) {
    #adminProfileBox {
      flex-direction: column;
      align-items: stretch;
    }
    #adminProfileBox .profile-actions {
      flex-direction: row;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }
    #adminProfileBox .profile-actions .btn-small {
      min-width: 48%;
      padding: 8px 10px;
      box-sizing: border-box;
    }
    /* if you prefer fully stacked buttons on tiny devices, uncomment:
    #adminProfileBox .profile-actions { flex-direction: column; }
    #adminProfileBox .profile-actions .btn-small { width:100%; }
    */
  }

  /* Make export menu not overlap profile on small screens */
  #exportMenu { right: 8px; left: auto; top: 44px; }
}

/* Improve modal sizing for very small devices */
@media (max-width: 480px) {
  .modal { width: 96%; max-width: 96%; }
}

.status-pending {
  border-left: 4px solid #e74c3c;
  background: #fff6f6;
}

/* product card tweaks */
#productsList .order {
  border: 1px solid #eee;
  background: #fff;
  border-radius: 8px;
  padding: 10px;
  transition: box-shadow .12s ease;
}
#productsList .order:hover { box-shadow: 0 6px 18px rgba(15,23,42,0.06); }
#productsList img { border-radius:6px; display:block; }
#productsList .btn-small { font-size:13px; padding:6px 8px; }
#productFormWrap { background:#fff; border:1px solid #eee; padding:12px; border-radius:8px; }

  </style>
</head>
<body>
    <!-- Header Section -->
<header>
  <div class="container header-row">
    <div class="logo">
      <img src="img/logo.png" alt="afro daafi and pizza Logo" />
      <h1>afro daafi and pizza</h1>
    </div>

    <!-- Mobile icons (order, shop) â€” inserted BEFORE nav to show on mobile left -->
    <div id="mobileIcons" class="mobile-icons" aria-hidden="false"></div>

    <nav role="navigation" aria-label="Primary">
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="menu.html">Menu</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="contact.html">Contact</a></li>
        <li><a href="order-track.html">Tracking</a></li>

        <!-- Desktop-visible Cart & Orders (we will hide on mobile via CSS/class) -->
        <li><a href="#" id="cartLink">Cart <span class="cart-count">0</span></a></li>
        <li><a href="#" id="orderHistoryLink">Orders</a></li>

        <!-- Visitor profile -->
        <li><a href="#" id="profileLink">Login</a></li>

        <!-- Admin dashboard (single place) + admin bell (single place) -->
        <li id="adminLi" style="display:none;"><a href="#" id="adminLink">Admin</a></li>
        <li id="orderBellLi" style="display:none;">
          <a href="#" id="orderBell" title="Admin orders" aria-label="Admin orders">
            <span class="bell-icon" aria-hidden="true">ðŸ””</span>
            <span id="orderBellCount" class="cart-count">0</span>
          </a>
        </li>
      </ul>
    </nav>

    <!-- hamburger injected elsewhere if you already have it; this header won't interfere -->
  </div>
</header>
<!-- ===== end header ===== -->

  <div class="admin-wrap">

    <div class="admin-row">
      <div class="card" style="flex:1;">
        <div style="display:flex; gap:12px; align-items:center; width:100%;">
        

          <div class="filters" style="flex:1;">
            <!-- Period selector (new) -->
            <select id="periodSelect" class="search-input" style="width:160px;">
              <option value="today">Today</option>
              <option value="week">This week</option>
              <option value="month">This month</option>
              <option value="year">This year</option>
              <option value="all">All</option>
            </select>

     

            <select id="statusFilter">
              <option value="pending">Pending</option>
              <option value="all">All statuses</option>
              <option value="confirmed">Confirmed</option>
              <option value="delivered">Delivered</option>
              <option value="denied">Denied</option>
            </select>

            <div style="position:relative;">
              <button id="exportBtn" class="btn-small card">
                Export <i class="fa fa-caret-down"></i>
              </button>
              <div id="exportMenu" class="card hidden" style="position:absolute; right:0; top:40px; min-width:120px; z-index:99;">
                <button class="btn-small" data-export="csv">Export CSV</button><br>
                <button class="btn-small" data-export="pdf">Export PDF</button>
              </div>
            </div>
            
            <!-- <button id="refreshBtn" class="btn-small card">Refresh</button> -->

            <button id="contactsTab" class="btn-small">
              Contacts
              <span id="contactsUnread" class="cart-count">0</span>
            </button>
            
            <!-- Search that will apply within the selected period -->
            <input id="searchInput" class="search-input" placeholder="Search by name, phone, id, district..." />
            <!-- <input id="contactsSearch" placeholder="Search name / phone / email"> -->

            <button id="refreshBtn" class="btn-small card">
              <i class="fa fa-refresh"></i>
            </button>
            
            
            <div id="contactsList"></div>

          </div>

          <div class="profile-box card" id="adminProfileBox">
            <div id="adminInfo">Not signed in</div>
            <div style="margin-top:8px;">
              <button id="openProfileBtn" class="btn-small">Edit Profile</button>
              <button id="adminLogoutBtn" class="btn-small">Logout</button>
            </div>
          </div>
        </div>

        <!-- Totals panel (new) -->
        <div class="totals-row" style="margin-top:12px;" id="periodTotals">
          <div class="tot-card">
            <h4>Orders (selected)</h4>
            <p id="totAll">0</p>
          </div>
          <div class="tot-card">
            <h4>Confirmed</h4>
            <p id="totConfirmed">0</p>
          </div>
          <div class="tot-card">
            <h4>Delivered</h4>
            <p id="totDelivered">0</p>
          </div>
          <div class="tot-card">
            <h4>Revenue (confirmed+delivered)</h4>
            <p id="totMoney">$0.00</p>
          </div>
        </div>

      </div>
    </div>

    <div id="ordersList" class="card" style="margin-top:12px;">
      Loading orders...
    </div>
  </div>

  <!-- Order View Modal (hidden until used) -->
  <div id="orderViewModal" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="orderViewTitle">
      <div class="modal-header">
        <div>
          <h3 id="orderViewTitle">Order</h3>
          <small id="orderViewSub"></small>
        </div>
        <div><button id="closeOrderView" class="btn-small">Close</button></div>
      </div>
      <div class="modal-body" id="orderViewBody">
        <!-- details injected here -->
      </div>
      <div class="modal-footer" id="orderViewFooter">
        <!-- actions injected here -->
      </div>
    </div>
  </div>

    <!-- Cart Modal -->
    <div class="cart-modal" id="cartModal">
      <div class="cart-content">
        <div class="cart-header">
          <h2>Your Cart</h2>
          <span class="close-btn" id="closeCart">&times;</span>
        </div>
        <div class="cart-body">
          <div id="cartItems">
            <p class="empty-cart-message">Your cart is empty</p>
          </div>
          <div class="cart-footer">
            <div class="cart-total">
              <h3>Total: $<span id="cartTotal">0.00</span></h3>
            </div>
            <button class="btn-primary checkout-btn" id="checkoutBtn">Checkout</button>
          </div>
        </div>
      </div>
    </div>


 <!-- Footer -->
 <footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-section">
        <h3>afro daafi and pizza</h3>
        <p>Delivering delicious food with love since 2025</p>
      </div>
      <div class="footer-section">
        <h3>Quick Links</h3>
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="menu.html">Menu</a></li>
          <li><a href="about.html">About</a></li>
          <li><a href="contact.html">Contact</a></li>
        </ul>
      </div>
      <div class="footer-section">
        <h3>Contact Us</h3>
        <p><i class="fas fa-map-marker-alt"></i> Mogadishu, Banadir region</p>
        <p><i class="fas fa-phone"></i> (123) 456-7890</p>
        <p><i class="fas fa-envelope"></i> info@foodiedelight.com</p>
      </div>
    </div>
    <div class="footer-bottom">
      <p>&copy; 2026 afro daafi and pizza. All rights reserved.</p>
    </div>
  </div>
</footer>

  <!-- Firebase DB module -->
  <script type="module" src="database.js"></script>
  <script src="script.js"></script>
  
  <script>
    (function() {
      // Wait for DOM ready
      document.addEventListener('DOMContentLoaded', () => {
        const profileBox = document.getElementById('adminProfileBox');
        if (!profileBox) return;
    
        // Save original placement so we can restore on large screens
        const originalParent = profileBox.parentNode;
        const originalNext = profileBox.nextElementSibling;
    
        // Ensure buttons are inside .profile-actions (so CSS can target them)
        let actions = profileBox.querySelector('.profile-actions');
        if (!actions) {
          actions = document.createElement('div');
          actions.className = 'profile-actions';
          // move all direct child buttons into actions
          const buttons = Array.from(profileBox.querySelectorAll('button'));
          buttons.forEach(btn => actions.appendChild(btn));
          profileBox.appendChild(actions);
        }
    
        // reposition helper
        function layoutForWidth(w) {
          const wrap = document.querySelector('.admin-wrap');
          if (!wrap) return;
          if (w <= 992) {
            // place profileBox at the top of .admin-wrap (first child)
            if (profileBox.parentNode !== wrap) wrap.insertBefore(profileBox, wrap.firstChild);
          } else {
            // restore original location (if still in DOM)
            if (profileBox.parentNode !== originalParent) {
              if (originalNext && originalNext.parentNode === originalParent) {
                originalParent.insertBefore(profileBox, originalNext);
              } else {
                originalParent.appendChild(profileBox);
              }
            }
          }
        }
    
        // initial layout
        layoutForWidth(window.innerWidth);
    
        // react to resize
        let resizeTO;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTO);
          resizeTO = setTimeout(() => layoutForWidth(window.innerWidth), 120);
        });
      });
    })();
    </script>
    <script>
      // small helper to wait for FirebaseDB to be ready
      async function waitForFirebaseDB(ms = 5000) {
        const start = Date.now();
        while (!window.FirebaseDB && Date.now() - start < ms) {
          await new Promise(r => setTimeout(r, 150));
        }
        return !!window.FirebaseDB;
      }
      
      // subscribe to auth/admin state and set window.currentAdmin
      (async function initAdminWatcher() {
        const ok = await waitForFirebaseDB(5000);
        if (!ok) {
          console.warn('FirebaseDB not ready for admin watcher');
          return;
        }
      
        // onAuthStateChange should call callback with null or { uid, email, adminDoc }
        if (typeof window.FirebaseDB.onAuthStateChange === 'function') {
          window.FirebaseDB.onAuthStateChange((user) => {
            // store globally so other scripts can check
            window.currentAdmin = user;
            console.log('onAuthStateChange -> currentAdmin =', user);
            // UI updates: show admin links / enable product actions
            const productsBtn = document.getElementById('productsTab');
            const adminLink = document.getElementById('adminLink');
            if (user && user.adminDoc) {
              // user is authenticated & listed as admin in your admins/admin collection
              if (productsBtn) { productsBtn.disabled = false; productsBtn.style.display = ''; }
              if (adminLink) adminLink.style.display = '';
            } else {
              // not admin or logged out
              if (productsBtn) { productsBtn.disabled = true; /* keep visible but disabled if you prefer */ }
              if (adminLink) adminLink.style.display = 'none';
            }
          });
        } else {
          console.warn('FirebaseDB.onAuthStateChange not available â€” ensure database.js exposes it');
        }
      })();
      </script>
      
  <script>

    // admin.html â€” restore admin session BEFORE anything else
(function restoreAdminSession() {
  try {
    const signed = localStorage.getItem('adminSigned');
    const doc = localStorage.getItem('adminDoc');

    if (signed === '1' && doc) {
      const admin = JSON.parse(doc);

      if (admin && admin.email) {
        // IMPORTANT: reuse the SAME function
        setAdminSignedIn(admin);
      } else {
        // corrupted data â†’ force logout
        localStorage.removeItem('adminSigned');
        localStorage.removeItem('adminDoc');
      }
    }
  } catch (e) {
    console.warn('Admin restore failed', e);
  }
})();

    // ADMIN PAGE SCRIPT (updated with period filters & totals)
    let unsubOrders = null;
    let ordersCache = [];
    let currentAdmin = null;

    // UI refs
    const ordersList = document.getElementById('ordersList');
    const searchInput = document.getElementById('searchInput');
    const statusFilter = document.getElementById('statusFilter');
    const refreshBtn = document.getElementById('refreshBtn');
    const adminInfo = document.getElementById('adminInfo');
    const openProfileBtn = document.getElementById('openProfileBtn');
    const adminLogoutBtn = document.getElementById('adminLogoutBtn');

    const periodSelect = document.getElementById('periodSelect');
    const totAll = document.getElementById('totAll');
    const totConfirmed = document.getElementById('totConfirmed');
    const totDelivered = document.getElementById('totDelivered');
    const totMoney = document.getElementById('totMoney');

    const orderViewModal = document.getElementById('orderViewModal');
    const orderViewBody = document.getElementById('orderViewBody');
    const orderViewFooter = document.getElementById('orderViewFooter');
    const orderViewTitle = document.getElementById('orderViewTitle');
    const orderViewSub = document.getElementById('orderViewSub');
    const closeOrderView = document.getElementById('closeOrderView');

    closeOrderView.addEventListener('click', () => { hideOrderView(); });
    orderViewModal.addEventListener('click', (e) => { if (e.target === orderViewModal) hideOrderView(); });

// ================= CONTACTS ADMIN (modal + realtime + search + unread + delete) =================
let contactsCache = [];
let unsubContacts = null;
let contactModalEl = null;
let contactDetailModalEl = null;

const contactsTabBtn = document.getElementById('contactsTab');
const contactsUnreadBadge = document.getElementById('contactsUnread');
const contactsRefreshBtn = document.getElementById('contactsRefreshBtn');

// Build / ensure the contact list modal
function ensureContactModal() {
  if (contactModalEl) return contactModalEl;
  const modal = document.createElement('div');
  modal.id = 'contactModal';
  modal.className = 'modal-backdrop';
  modal.style.display = 'none';
  modal.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true" style="max-width:820px;">
      <div class="modal-header">
        <div><h3>Contacts</h3><small id="contactModalSub"></small></div>
        <div><button id="closeContactModal" class="btn-small">Close</button></div>
      </div>
      <div class="modal-body" style="padding:16px;">
        <div style="display:flex; gap:12px; flex-direction:column;">
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
            <input id="contactModalSearch" placeholder="Search name / phone / email" class="search-input" style="flex:1;" />
            <button id="contactModalRefresh" class="btn-small">Refresh</button>
          </div>
          <div id="contactsListModal" style="max-height:60vh; overflow:auto;"></div>
        </div>
      </div>
      <div class="modal-footer">
        <small class="small-note">Messages newest first.</small>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  document.getElementById('closeContactModal').addEventListener('click', () => { modal.style.display = 'none'; });
  document.getElementById('contactModalRefresh').addEventListener('click', async () => { await manualContactsRefresh(); });

  document.getElementById('contactModalSearch').addEventListener('input', () => {
    const q = document.getElementById('contactModalSearch').value.trim().toLowerCase();
    const filtered = contactsCache.filter(c => {
      const s = `${c.name||''} ${c.phone||''} ${c.email||''} ${c.message||''}`.toLowerCase();
      return s.includes(q);
    });
    renderContactsList(filtered);
  });

  contactModalEl = modal;
  return modal;
}

// Build / ensure the contact detail modal (full screen on mobile)
function ensureContactDetailModal() {
  if (contactDetailModalEl) return contactDetailModalEl;
  const m = document.createElement('div');
  m.id = 'contactDetailModal';
  m.className = 'modal-backdrop';
  m.style.display = 'none';
  m.innerHTML = `
    <div class="modal" role="dialog" aria-modal="true" style="max-width:720px;">
      <div class="modal-header">
        <div><h3 id="contactDetailTitle">Message</h3><small id="contactDetailWhen"></small></div>
        <div><button id="closeContactDetail" class="btn-small">Close</button></div>
      </div>
      <div class="modal-body" id="contactDetailBody" style="padding:16px; max-height:70vh; overflow:auto;"></div>
      <div class="modal-footer" id="contactDetailFooter"></div>
    </div>
  `;
  document.body.appendChild(m);
  document.getElementById('closeContactDetail').addEventListener('click', () => { m.style.display = 'none'; });
  contactDetailModalEl = m;
  return m;
}

// render contacts list inside modal
function renderContactsList(list) {
  const container = document.getElementById('contactsListModal');
  if (!container) return;
  if (!list || list.length === 0) { container.innerHTML = '<p>No messages</p>'; return; }

  container.innerHTML = list.map(c => {
    const when = c.createdAt && c.createdAt.seconds ? new Date(c.createdAt.seconds * 1000).toLocaleString() : '';
    return `
      <div class="order ${c.read ? '' : 'status-pending'}" data-id="${c.id}" style="padding:10px; margin-bottom:8px;">
        <div style="display:flex; justify-content:space-between; gap:8px; align-items:flex-start;">
          <div style="flex:1;">
            <strong>${escapeHtml(c.name||'')}</strong>
            <div style="font-size:13px; color:#666; margin-top:4px;">${escapeHtml(c.phone||'')} â€¢ ${escapeHtml(c.email||'')}</div>
            <div style="margin-top:8px; color:#333;">${escapeHtml((c.message||'').slice(0,220))}${(c.message && c.message.length>220)?'...':''}</div>
          </div>
          <div style="min-width:120px; text-align:right;">
            <div style="font-size:12px; color:#666;">${escapeHtml(when)}</div>
            <div style="margin-top:8px; display:flex; gap:6px; justify-content:flex-end;">
              ${c.read ? '' : `<button class="btn-small markReadInline" data-id="${c.id}">Mark read</button>`}
              <button class="btn-small viewContactBtn" data-id="${c.id}">View</button>
              <button class="btn-small deleteContactBtn" data-id="${c.id}" title="Delete"><i class="fa fa-trash"></i></button>
            </div>
          </div>
        </div>
      </div>
    `;
  }).join('');

  // wire actions
  container.querySelectorAll('.viewContactBtn').forEach(b=>{
    b.onclick = async () => {
      const id = b.dataset.id;
      const contact = contactsCache.find(x => x.id === id);
      if (!contact) return;
      openContactDetail(contact);
      // mark read
      if (contact.read !== true && window.FirebaseDB && typeof window.FirebaseDB.markContactRead === 'function') {
        await window.FirebaseDB.markContactRead(id);
        contact.read = true;
        updateUnreadBadgeCount();
        renderContactsList(contactsCache);
      }
    };
  });

  container.querySelectorAll('.markReadInline').forEach(b=>{
    b.onclick = async (ev) => {
      const id = b.dataset.id;
      if (window.FirebaseDB && typeof window.FirebaseDB.markContactRead === 'function') {
        await window.FirebaseDB.markContactRead(id);
        const c = contactsCache.find(x => x.id === id);
        if (c) c.read = true;
        updateUnreadBadgeCount();
        renderContactsList(contactsCache);
      }
    };
  });

  container.querySelectorAll('.deleteContactBtn').forEach(b=>{
    b.onclick = async (ev) => {
      ev.stopPropagation();
      const id = b.dataset.id;
      if (!confirm('Delete this contact message permanently?')) return;
      if (!window.FirebaseDB || typeof window.FirebaseDB.deleteContact !== 'function') { alert('Delete not available'); return; }
      const res = await window.FirebaseDB.deleteContact(id);
      if (res && res.success) {
        // remove from local cache and rerender
        contactsCache = contactsCache.filter(x => x.id !== id);
        updateUnreadBadgeCount();
        renderContactsList(contactsCache);
        showToast('Contact deleted');
      } else {
        alert('Delete failed');
      }
    };
  });
}

// Open the detailed modal (full-screen friendly) for a contact
function openContactDetail(contact) {
  const modal = ensureContactDetailModal();
  const when = contact.createdAt && contact.createdAt.seconds ? new Date(contact.createdAt.seconds * 1000).toLocaleString() : '';
  document.getElementById('contactDetailTitle').textContent = contact.name || 'Message';
  document.getElementById('contactDetailWhen').textContent = when;
  document.getElementById('contactDetailBody').innerHTML = `
    <div style="font-size:13px; color:#666;">${escapeHtml(contact.email||'')} â€¢ ${escapeHtml(contact.phone||'')}</div>
    <div style="margin-top:12px; font-size:14px; color:#222;">${escapeHtml(contact.message||'')}</div>
    <hr/>
    <div style="font-size:13px; color:#666;">Location hint: ${escapeHtml(contact.locationHint||'')}</div>
  `;
  const footer = document.getElementById('contactDetailFooter');
  footer.innerHTML = `
    <button id="contactReplyBtn" class="btn-small">Reply</button>
    <button id="contactMarkReadBtn" class="btn-small">${contact.read ? 'Mark unread' : 'Mark read'}</button>
    <button id="contactDeleteBtn" class="btn-small"><i class="fa fa-trash"></i> Delete</button>
  `;

  document.getElementById('contactReplyBtn').onclick = () => {
    window.location.href = `mailto:${contact.email}?subject=${encodeURIComponent('Re: your afro daafi and pizza message')}`;
  };
  document.getElementById('contactMarkReadBtn').onclick = async () => {
    if (contact.read !== true) {
      await window.FirebaseDB.markContactRead(contact.id);
      contact.read = true;
    } else {
      // toggle unread (optional) - we'll mark read:false
      try {
        await updateDoc(doc(db, 'contacts', contact.id), { read: false });
        contact.read = false;
      } catch (e) { console.warn('mark unread failed', e); }
    }
    updateUnreadBadgeCount();
    renderContactsList(contactsCache);
    openContactDetail(contact); // refresh footer text
  };
  document.getElementById('contactDeleteBtn').onclick = async () => {
    if (!confirm('Delete this contact message permanently?')) return;
    const res = await window.FirebaseDB.deleteContact(contact.id);
    if (res && res.success) {
      contactsCache = contactsCache.filter(x => x.id !== contact.id);
      updateUnreadBadgeCount();
      renderContactsList(contactsCache);
      modal.style.display = 'none';
      showToast('Contact deleted');
    } else {
      alert('Delete failed');
    }
  };

  modal.style.display = 'flex';
}

// update unread badge (uses client-side count so it works even if docs use handled instead of read)
async function updateUnreadBadgeCount() {
  try {
    if (window.FirebaseDB && typeof window.FirebaseDB.getUnreadContactsCount === 'function') {
      const res = await window.FirebaseDB.getUnreadContactsCount();
      if (res.success) {
        const c = res.count || 0;
        contactsUnreadBadge.textContent = c;
        contactsUnreadBadge.style.display = c ? 'inline-block' : 'none';
        return;
      }
    }
  } catch(e){ console.warn('unread count api fail', e); }

  // fallback: count locally
  const count = (contactsCache || []).filter(x => x.read !== true).length;
  contactsUnreadBadge.textContent = count;
  contactsUnreadBadge.style.display = count ? 'inline-block' : 'none';
}

// manual one-shot refresh
async function manualContactsRefresh() {
  if (!window.FirebaseDB || typeof window.FirebaseDB.listContacts !== 'function') return;
  const res = await window.FirebaseDB.listContacts();
  if (res && res.success) {
    contactsCache = res.contacts || [];
    renderContactsList(contactsCache);
    updateUnreadBadgeCount();
  } else {
    console.warn('manualContactsRefresh failed', res && res.error);
  }
}

// start realtime listener (or fallback)
async function startContactsListener() {
  ensureContactModal();
  if (unsubContacts) { try { unsubContacts(); } catch(e) {} unsubContacts = null; }

  const ok = await waitForFirebaseDB(4000);
  if (!ok || !window.FirebaseDB) { await manualContactsRefresh(); return; }

  if (typeof window.FirebaseDB.onContactsSnapshot === 'function') {
    try {
      unsubContacts = window.FirebaseDB.onContactsSnapshot(list => {
        contactsCache = list || [];
        renderContactsList(contactsCache);
        updateUnreadBadgeCount();
      });
      updateUnreadBadgeCount();
    } catch (e) {
      console.warn('startContactsListener fallback', e);
      await manualContactsRefresh();
    }
  } else {
    await manualContactsRefresh();
  }
}

// contactsTab opens modal & starts listener
contactsTabBtn.addEventListener('click', async () => {
  if (!currentAdmin) { alert('Admin only'); return; }
  const m = ensureContactModal();
  m.style.display = 'flex';
  const search = document.getElementById('contactModalSearch');
  if (search) search.value = '';
  await startContactsListener();
});








/* ---------- small toast ---------- */
function showToast(msg, t = 1700) {
  let c = document.getElementById('adminToastContainer');
  if (!c) {
    c = document.createElement('div');
    c.id = 'adminToastContainer';
    c.style.position = 'fixed';
    c.style.right = '18px';
    c.style.bottom = '18px';
    c.style.zIndex = 99999;
    document.body.appendChild(c);
  }
  const el = document.createElement('div');
  el.style.background = 'rgba(0,0,0,0.8)';
  el.style.color = '#fff';
  el.style.padding = '8px 12px';
  el.style.marginTop = '8px';
  el.style.borderRadius = '6px';
  el.textContent = msg;
  c.appendChild(el);
  setTimeout(() => { el.style.transition='opacity 250ms'; el.style.opacity='0'; setTimeout(()=>el.remove(), 260); }, t);
}
















/////



    function showOrderView(order) {
  if (!order) return;
  orderViewTitle.textContent = `Order # ${order.id}`;
  const created = order.createdAt && order.createdAt.seconds ? new Date(order.createdAt.seconds*1000).toLocaleString() : (order.timestamp ? new Date(order.timestamp).toLocaleString() : '');
  orderViewSub.textContent = `${created} â€¢ ${ (order.status || order.paymentStatus || 'pending').toUpperCase() }`;

  // build items list with size & extras
  const itemsListHtml = (order.items || []).map(it => {
    const sizeHtml = it.sizeName ? `<span style="color:#333; font-weight:600;">Size: ${escapeHtml(it.sizeName)}</span>` : '';
    const extrasHtml = (it.extras && it.extras.length) ? `<div style="font-size:13px; color:#555; margin-top:4px;">Extras: ${it.extras.map(e => escapeHtml(e.name)).join(', ')}</div>` : '';
    return `<li style="margin-bottom:8px;">
              <div><strong>${escapeHtml(it.name)}</strong> &nbsp; x ${it.quantity} &nbsp; â€” &nbsp; $${(it.price * it.quantity).toFixed(2)}</div>
              <div style="margin-top:4px;">${sizeHtml}${extrasHtml}</div>
            </li>`;
  }).join('');

  orderViewBody.innerHTML = `
    <div><strong>Customer:</strong> ${escapeHtml(order.visitorName || 'Guest')} â€¢ ${escapeHtml(order.phone || '')}</div>
    <div style="margin-top:6px;"><strong>Address:</strong> ${escapeHtml(order.district || '')} / ${escapeHtml(order.area || '')} ${order.otherPlace ? ' - ' + escapeHtml(order.otherPlace) : ''}</div>
    <hr />
    <div><strong>Items</strong></div>
    <ul class="order-items" style="margin-top:8px; padding-left:18px;">
      ${itemsListHtml || '<li>No items</li>'}
    </ul>
    <div style="margin-top:8px;"><strong>Total:</strong> $${(order.total || 0).toFixed(2)}</div>
    <div style="margin-top:8px;"><strong>Notes:</strong> ${escapeHtml(order.note || '')}</div>
  `;

  // Footer actions
  orderViewFooter.innerHTML = `
    <button class="btn-small" id="viewConfirmBtn">Confirm</button>
    <button class="btn-small" id="viewDeliveredBtn">Delivered</button>
    <button class="btn-small" id="viewDenyBtn">Deny</button>
    <button class="btn-small" id="viewDeleteBtn">Delete</button>
  `;
// attach actions (overwrite any previous handlers)
document.getElementById('viewConfirmBtn').onclick = () => changeStatusWithConfirm(order.id, 'confirmed');
document.getElementById('viewDeliveredBtn').onclick = () => changeStatusWithConfirm(order.id, 'delivered');
document.getElementById('viewDenyBtn').onclick = () => changeStatusWithConfirm(order.id, 'denied');
document.getElementById('viewDeleteBtn').onclick = () => { if (confirm(`Delete order ${order.id} permanently?`)) deleteOrderCompletely(order.id); };




  orderViewModal.style.display = 'flex';
  orderViewModal.setAttribute('aria-hidden', 'false');
}

    function hideOrderView() {
      orderViewModal.style.display = 'none';
      orderViewModal.setAttribute('aria-hidden', 'true');
    }

    function escapeHtml(s) {
      if (!s && s !== 0) return '';
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

async function changeStatusWithConfirm(orderId, newStatus) {
  // create tracking sets if missing
  if (!window._confirmingOrders) window._confirmingOrders = new Set();
  if (!window._updatingOrders) window._updatingOrders = new Set();

  // prevent duplicate confirm dialogs / re-entrancy
  if (window._confirmingOrders.has(orderId)) {
    showToast('Action already in progress for this order', 1600, 'info');
    return;
  }
  window._confirmingOrders.add(orderId);

  try {
    const idx = ordersCache.findIndex(x => String(x.id || x.localId || '') === String(orderId));
    const ord = idx !== -1 ? ordersCache[idx] : null;
    const currentStatus = (ord && (ord.status || ord.paymentStatus)) ? String((ord.status || ord.paymentStatus)).toLowerCase() : 'pending';

    // if already same status, skip and inform
    if (currentStatus === newStatus) {
      showToast(`Order already ${newStatus}`, 1400, 'info');
      return;
    }

    // prevent repeated update if one already running for this order
    if (window._updatingOrders.has(orderId)) {
      showToast('Update already running for this order', 1400, 'info');
      return;
    }

    // single confirm prompt
    const ok = confirm(`Change order ${orderId} to status "${newStatus}"?`);
    if (!ok) return;

    window._updatingOrders.add(orderId);

    // optimistic update locally
    if (idx !== -1) {
      ordersCache[idx] = { ...ordersCache[idx], status: newStatus };
      applyFiltersAndRender();
    }

    // server call (if helper exists)
    let res = null;
    if (window.FirebaseDB && typeof window.FirebaseDB.updateOrderStatus === 'function') {
      try {
        res = await window.FirebaseDB.updateOrderStatus(orderId, newStatus);
      } catch (e) {
        console.warn('updateOrderStatus failed', e);
        res = { success: false, error: e };
      }
    } else {
      // fallback: persist in localStorage only
      try {
        const localOrders = JSON.parse(localStorage.getItem('orders') || '[]');
        const li = localOrders.findIndex(lo => String(lo.localId || lo.remoteId || lo.id || '') === String(orderId));
        if (li !== -1) {
          localOrders[li].status = newStatus;
          localStorage.setItem('orders', JSON.stringify(localOrders));
        }
        res = { success: true, localOnly: true };
      } catch (e) { res = { success:false, error:e }; }
    }

    if (!res || !res.success) {
      // revert if possible
      if (idx !== -1) {
        ordersCache[idx].status = ord ? ord.status : (ord && ord.paymentStatus) ? ord.paymentStatus : 'pending';
        applyFiltersAndRender();
      }
      if (res && res.error) console.error(res.error);
      alert('Failed to update status');
      return;
    }

    // merge server updatedOrder if returned
    if (res.updatedOrder && idx !== -1) {
      ordersCache[idx] = { ...ordersCache[idx], ...res.updatedOrder };
    }

    // toast with type
    const toastType = (newStatus === 'confirmed') ? 'confirmed'
                    : (newStatus === 'delivered')  ? 'delivered'
                    : (newStatus === 'denied')     ? 'denied'
                    : 'info';
    showToast(`Order ${orderId} set to ${newStatus}`, 2200, toastType);

    applyFiltersAndRender();

    // close modal if it's open for this order
    if (orderViewModal && orderViewModal.style.display === 'flex') {
      try {
        const shownId = orderViewTitle && orderViewTitle.textContent ? (orderViewTitle.textContent.match(/#\s*(\S+)/) || [])[1] : null;
        if (!shownId || String(shownId) === String(orderId)) hideOrderView();
      } catch (e) { hideOrderView(); }
    }
  } finally {
    window._confirmingOrders.delete(orderId);
    window._updatingOrders.delete(orderId);
  }
}


function showToast(message, t = 2200, type = 'info') {
  let container = document.getElementById('adminToastContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'adminToastContainer';
    container.style.position = 'fixed';
    container.style.right = '18px';
    container.style.bottom = '18px';
    container.style.zIndex = 99999;
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.alignItems = 'flex-end';
    container.style.gap = '8px';
    document.body.appendChild(container);
  }

  const el = document.createElement('div');
  el.className = 'admin-toast';
  el.style.padding = '9px 14px';
  el.style.borderRadius = '8px';
  el.style.minWidth = '160px';
  el.style.boxShadow = '0 6px 18px rgba(12,15,20,0.08)';
  el.style.color = '#fff';
  el.style.fontWeight = 600;
  el.style.letterSpacing = '0.2px';
  el.style.opacity = '1';
  el.style.transition = 'opacity 260ms, transform 240ms';
  el.style.transform = 'translateY(0)';

  // type styles
  if (type === 'confirmed') {
    el.style.background = 'linear-gradient(90deg,#0b74ff,#0b9bff)';
  } else if (type === 'delivered') {
    el.style.background = 'linear-gradient(90deg,#16a34a,#22c55e)';
  } else if (type === 'denied') {
    el.style.background = 'linear-gradient(90deg,#ef4444,#fb7185)';
  } else {
    // info / default
    el.style.background = 'linear-gradient(90deg, rgba(15,23,36,0.9), rgba(15,23,36,0.8))';
  }

  el.textContent = message;
  container.appendChild(el);

  // auto-hide
  setTimeout(() => {
    el.style.opacity = '0';
    el.style.transform = 'translateY(8px)';
    setTimeout(() => el.remove(), 280);
  }, t);
}

    // ---------- Period filtering helpers ----------
    function orderTimestampMs(o) {
      if (!o) return 0;
      if (o.createdAt && o.createdAt.seconds) return o.createdAt.seconds * 1000;
      if (o.timestamp) {
        const t = Date.parse(o.timestamp);
        if (!isNaN(t)) return t;
      }
      // fallback: use now (shouldn't happen)
      return Date.now();
    }

    function startOfToday() {
      const d = new Date();
      d.setHours(0,0,0,0);
      return d.getTime();
    }
   
    function endOfToday() {
      const d = new Date();
      d.setHours(23,59,59,999);
      return d.getTime();
    }
   
    function startOfWeek() {
  const d = new Date();
  const day = d.getDay(); // 0=Sun
  const diff = (day >= 6) ? 6 - day : -1 - day; // Saturday start
  d.setDate(d.getDate() + diff);
  d.setHours(0,0,0,0);
  return d.getTime();
}

    function startOfMonth() {
      const d = new Date();
      d.setDate(1);
      d.setHours(0,0,0,0);
      return d.getTime();
    }
   
    function startOfYear() {
      const d = new Date();
      d.setMonth(0,1);
      d.setHours(0,0,0,0);
      d.setDate(1);
      return d.getTime();
    }

    function isInPeriod(o, period) {
      const t = orderTimestampMs(o);
      if (period === 'today') {
        return t >= startOfToday() && t <= endOfToday();
      } else if (period === 'week') {
        return t >= startOfWeek() && t <= Date.now();
      } else if (period === 'month') {
        return t >= startOfMonth() && t <= Date.now();
      } else if (period === 'year') {
        return t >= startOfYear() && t <= Date.now();
      } else { // all
        return true;
      }
    }

    // Replace your existing shareLink branch with this function call:
async function openShareModalForOrder(ord) {
  // ord should be the order object (may have localId, remoteId, id)
  const docId = ord && (ord.id || ord.remoteId) ? (ord.id || ord.remoteId) : (ord.localId || '');
  const localId = ord && ord.localId ? ord.localId : '';
  // build a tracking URL that includes docId (if known) and localId
  // prefer docId in param "id" (firestore doc id) when available; fallback to localId
  const trackBase = `${location.origin}/order-track.html`;
  const params = new URLSearchParams();
  if (docId) params.set('id', docId);
  if (localId && (!docId || docId.indexOf('local_') === 0)) params.set('local', localId);
  // Admin can choose role for the recipient (driver/customer)
  // The modal UI below allows selecting contacts and role.

  // Build modal DOM
  let m = document.getElementById('shareOrderModal');
  if (!m) {
    m = document.createElement('div');
    m.id = 'shareOrderModal';
    m.className = 'cart-modal';
    m.innerHTML = `
      <div class="cart-content" style="max-width:520px;">
        <div class="cart-header"><h3>Share tracking link</h3><span class="close-btn" id="closeShareModal">&times;</span></div>
        <div class="cart-body" style="padding:12px;">
          <div style="margin-bottom:8px;">
            <label>Role for recipient</label><br/>
            <select id="shareRole" style="width:100%; padding:8px; margin-top:6px;">
              <option value="driver">Driver (open with driver UI)</option>
              <option value="customer">Customer (customer UI)</option>
            </select>
          </div>

          <div style="margin-bottom:8px;">
            <label>Select contacts (or paste numbers, comma separated)</label>
            <div id="shareContactsList" style="max-height:160px; overflow:auto; border:1px dashed #e6eef9; padding:8px; border-radius:6px;"></div>
            <div style="margin-top:8px;">
              <input id="shareManualNumbers" placeholder="e.g. 617123456, 627123456" style="width:100%; padding:8px;" />
            </div>
          </div>

          <div style="text-align:right;">
            <button id="sendShareBtn" class="btn-primary">Send to selected</button>
            <button id="copyShareBtn" class="btn" style="margin-left:8px;">Copy message</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(m);

    document.getElementById('closeShareModal').addEventListener('click', ()=> m.style.display='none');
    m.addEventListener('click', (e)=> { if (e.target === m) m.style.display='none'; });
  }

  // populate contacts list from your contacts collection (if available) else allow manual entry
  const contactsContainer = document.getElementById('shareContactsList');
  contactsContainer.innerHTML = '<div style="color:#666">Loading contacts...</div>';
  let contacts = [];
  try {
    if (window.FirebaseDB && typeof window.FirebaseDB.listContacts === 'function') {
      const res = await window.FirebaseDB.listContacts();
      if (res && res.success) contacts = res.contacts || [];
    }
  } catch(e) { console.warn('listContacts failed', e); }
  // render simple checkboxes for numbers
  if (contacts.length === 0) {
    contactsContainer.innerHTML = '<div style="color:#666">No saved contacts (or failed to load). You can paste numbers below.</div>';
  } else {
    contactsContainer.innerHTML = contacts.map(c => {
      const phone = (c.phone || c.number || '').replace(/\s+/g,'');
      return `<label style="display:block; margin-bottom:6px;"><input type="checkbox" data-phone="${encodeURIComponent(phone)}"> ${c.name || phone} â€” ${phone}</label>`;
    }).join('');
  }

  document.getElementById('sendShareBtn').onclick = function() {
    const role = document.getElementById('shareRole').value || 'driver';
    // gather selected phones
    const checked = Array.from(contactsContainer.querySelectorAll('input[type=checkbox]:checked')).map(n => decodeURIComponent(n.dataset.phone));
    // manual numbers
    const manual = (document.getElementById('shareManualNumbers').value || '').split(',').map(s => s.trim()).filter(Boolean);
    const phones = checked.concat(manual).filter(Boolean);

    if (phones.length === 0) {
      showToast && showToast('Select or paste at least one phone number');
      return;
    }

    const trackUrl = `${trackBase}?${params.toString()}&role=${encodeURIComponent(role)}`;
    const msg = `Delivery: Order ${ord.remoteId || ord.id || ord.localId || ''}\nCustomer: ${ord.visitorName||''} â€¢ ${ord.phone||''}\nOpen tracking: ${trackUrl}`;

    // open WhatsApp composer for each selected phone (note: this will open a tab per number)
    phones.forEach(p => {
      const cleaned = p.replace(/[^\d]/g,''); // remove + or spaces; WhatsApp expects no plus
      const wa = `https://wa.me/${cleaned}?text=${encodeURIComponent(msg)}`;
      window.open(wa, '_blank');
    });

    showToast && showToast('WhatsApp composer opened for selected numbers', 1600, 'info');
    m.style.display = 'none';
  };

  document.getElementById('copyShareBtn').onclick = function() {
    const role = document.getElementById('shareRole').value || 'driver';
    const trackUrl = `${trackBase}?${params.toString()}&role=${encodeURIComponent(role)}`;
    const msg = `Delivery: Order ${ord.remoteId || ord.id || ord.localId || ''}\nCustomer: ${ord.visitorName||''} â€¢ ${ord.phone||''}\nOpen tracking: ${trackUrl}`;
    navigator.clipboard && navigator.clipboard.writeText(msg).then(()=> showToast && showToast('Message copied') ).catch(()=> alert(msg));
  };

  m.style.display = 'flex';
}

    // filters ordersCache by period/status/search and then renders + updates totals
// Replace your existing applyFiltersAndRender with this exact function
function applyFiltersAndRender() {
  const q = (searchInput.value || '').trim().toLowerCase();
  const status = statusFilter ? statusFilter.value : 'all';
  const period = periodSelect ? periodSelect.value || 'today' : 'today';

  // first filter by period
  let filtered = (ordersCache || []).filter(o => isInPeriod(o, period));

  // status filter
  if (status !== 'all') filtered = filtered.filter(o => ((o.status || 'pending') === status));

  // search across visitorName, phone, id, district (within the period)
  if (q) {
    filtered = filtered.filter(o => {
      const s = `${o.visitorName||''} ${o.phone||''} ${o.id||''} ${o.district||''}`.toLowerCase();
      return s.includes(q);
    });
  }

  // update totals based on filtered set
  updateTotals(filtered);

  // render empty-state
  if (!filtered || filtered.length === 0) {
    ordersList.innerHTML = '<div style="padding:12px">No orders found for selected filters.</div>';
    return;
  }

  // helper: decide which action buttons to show (includes payment actions)
  function actionButtonsHtml(id, statusText, paymentStatus) {
    let html = '';
    // Payment actions (allow quickly marking payment)
    if (paymentStatus !== 'paid') {
      // allow admin to mark as paid or mark as COD
      html += `<button class="btn-small" data-action="markPaid" data-id="${id}">Mark Paid</button>`;
      html += `<button class="btn-small" data-action="markCOD" data-id="${id}">Mark COD</button>`;
    } else {
      // paid already - show readonly badge (no extra action)
      html += `<button class="btn-small" data-action="paidBadge" data-id="${id}" disabled>Paid</button>`;
    }

    
    // Status-specific actions
    if (statusText === 'pending') {
      html += `<button class="btn-small" data-action="confirm" data-id="${id}">Confirm</button>`;
      html += `<button class="btn-small" data-action="delivered" data-id="${id}">Delivered</button>`;
      html += `<button class="btn-small" data-action="deny" data-id="${id}">Deny</button>`;
    } else if (statusText === 'confirmed') {
      html += `<button class="btn-small" data-action="delivered" data-id="${id}">Delivered</button>`;
      html += `<button class="btn-small" data-action="unconfirm" data-id="${id}">Unconfirm</button>`;
    } else if (statusText === 'delivered') {
      html += `<button class="btn-small" data-action="undeliver" data-id="${id}">Mark pending</button>`;
    } else if (statusText === 'denied') {
      html += `<button class="btn-small" data-action="restore" data-id="${id}">Mark pending</button>`;
    } else {
      html += `<button class="btn-small" data-action="confirm" data-id="${id}">Confirm</button>`;
    }

    // view & delete always available
    html += `<button class="btn-small" data-action="view" data-id="${id}">View</button>`;
    html += `<button class="btn-small" data-action="delete" data-id="${id}">Delete</button>`;

    // Location quick link (open map with client/delivery coordinates when available)
    html += `<button class="btn-small" data-action="openMap" data-id="${id}">Map</button>`;

    // add near Map button (for example after Map)
html += `<button class="btn-small" data-action="shareLink" data-id="${id}">Share</button>`;


    return html;
  }

  // render markup
  ordersList.innerHTML = filtered.map(o => {
    const statusText = (o.status || o.paymentStatus || 'pending').toLowerCase();
    const paymentStatus = (o.paymentStatus || 'pending').toLowerCase();
    const created = o.createdAt && o.createdAt.seconds ? new Date(o.createdAt.seconds*1000).toLocaleString() : (o.timestamp ? new Date(o.timestamp).toLocaleString() : '');
    const itemsSummary = (o.items||[]).map(it => {
      let s = `${escapeHtml(it.name)}`;
      if (it.sizeName) s += ` (${escapeHtml(it.sizeName)})`;
      if (it.extras && it.extras.length) s += ` [${it.extras.map(e => escapeHtml(e.name)).join(', ')}]`;
      s += ` x ${it.quantity}`;
      return s;
    }).join(', ');

    return `
      <div class="order" data-id="${o.id || o.localId || ''}">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>${escapeHtml(o.visitorName || 'Guest')}</strong> â€¢ <small>${escapeHtml(o.phone || '')}</small><br>
            <small>${escapeHtml(o.district || '')} / ${escapeHtml(o.area || '')} ${o.otherPlace? ' - ' + escapeHtml(o.otherPlace) : ''}</small><br>
            <small>${escapeHtml(created)}</small>
          </div>
          <div style="text-align:right;">
            <div style="margin-bottom:6px;">
              <span class="status-pill ${statusText==='pending'?'status-pending':''} ${statusText==='confirmed'?'status-confirmed':''} ${statusText==='denied'?'status-denied':''} ${statusText==='delivered'?'status-delivered':''}">
                ${statusText.toUpperCase()}
              </span>
            </div>
            <div style="margin-bottom:6px;">
              <small>Payment: <strong>${(paymentStatus || 'pending').toUpperCase()}</strong></small>
            </div>
            <div>
              <strong>$${(o.total || 0).toFixed(2)}</strong>
            </div>
          </div>
        </div>
        <div style="margin-top:8px;">
          <small>${escapeHtml(itemsSummary)}</small>
        </div>
        <div style="margin-top:8px; text-align:right;">
          ${actionButtonsHtml(o.id || o.localId || '', statusText, paymentStatus)}
        </div>
      </div>
    `;
  }).join('');

  // ensure single delegated listener (attach only once)
  if (!ordersList.__delegateAttached) {
    ordersList.__delegateAttached = true;

    ordersList.addEventListener('click', async (ev) => {
      const btn = ev.target.closest('button[data-action]');
      if (!btn) return;
      const id = btn.getAttribute('data-id');
      const action = btn.getAttribute('data-action');

      // find order by id
      const ord = ordersCache.find(x => String(x.id || x.localId || '') === String(id));

      // view
      if (action === 'view') { if (ord) showOrderView(ord); return; }

      // delete
      if (action === 'delete') {
        if (!confirm(`Delete order ${id} permanently?`)) return;
        await deleteOrderCompletely(id);
        return;
      }

      // open map modal
      if (action === 'openMap') {
        openMapModalForOrder(ord || { id });
        return;
      }

      // payment actions
      if (action === 'markPaid') {
        await markPaymentWithConfirm(id, 'paid');
        return;
      }
      if (action === 'markCOD') {
        await markPaymentWithConfirm(id, 'cod');
        return;
      }
      if (action === 'shareLink') {
  // open the sharing modal (admin can pick contacts, role, copy message, etc.)
  if (typeof openShareModalForOrder === 'function') openShareModalForOrder(ord || { id });
  return;
}

      // map aliases to canonical statuses
      const aliasToStatus = {
        confirm: 'confirmed',
        delivered: 'delivered',
        deny: 'denied',
        unconfirm: 'pending',
        undeliver: 'pending',
        restore: 'pending'
      };
      const desired = aliasToStatus[action];
      if (!desired) return; // unknown action

      // use centralized function to handle confirm & update
      await changeStatusWithConfirm(id, desired);
    });
  }
}


    // update totals UI from a filtered orders array
    function updateTotals(filtered) {
      const totalCount = filtered.length;
      const confirmedArr = filtered.filter(o => (o.status || '').toLowerCase() === 'confirmed');
      const deliveredArr = filtered.filter(o => (o.status || '').toLowerCase() === 'delivered');

      // revenue: sum of totals for confirmed + delivered
      const money = filtered.reduce((s,o) => {
        const st = (o.status || '').toLowerCase();
        if (st === 'confirmed' || st === 'delivered') return s + (parseFloat(o.total) || 0);
        return s;
      }, 0);

      totAll.textContent = totalCount;
      totConfirmed.textContent = confirmedArr.length;
      totDelivered.textContent = deliveredArr.length;
      totMoney.textContent = `$${money.toFixed(2)}`;
    }

    // ---------- DB / auth / listener logic (unchanged behavior) ----------
    function waitForFirebaseDB(ms = 3000) {
      return new Promise((resolve) => {
        if (window.FirebaseDB) return resolve(true);
        const interval = 100;
        let waited = 0;
        const id = setInterval(() => {
          waited += interval;
          if (window.FirebaseDB) {
            clearInterval(id);
            return resolve(true);
          }
          if (waited >= ms) {
            clearInterval(id);
            return resolve(false);
          }
        }, interval);
      });
    }

    async function startOrdersListener() {
  // stop any previous unsub
  if (unsubOrders) { try { unsubOrders(); } catch(e){} unsubOrders = null; }

  // If admin explicitly wants realtime, keep old behavior (optional)
  // Default behavior: paginated reads (Spark friendly)
  // Wait for FirebaseDB
  const ready = await waitForFirebaseDB(4000);
  if (!ready || !window.FirebaseDB) {
    console.warn('Database helper not ready â€” attempting limited fetch');
    ordersList.innerHTML = '<div style="padding:12px;">Attempting to load orders...</div>';
    // limited fallback: load first page if available
    if (window.FirebaseDB && typeof window.FirebaseDB.listOrdersPage === 'function') {
      try { await fetchFirstOrdersPage(); return; } catch(e){ console.warn('fallback page fetch failed', e); }
    }
    ordersList.innerHTML = '<div style="padding:12px;">Realtime not available</div>';
    return;
  }

  // If caller wants realtime for recent orders, and helper exists, use it
  if (typeof window.FirebaseDB.onOrdersSnapshot === 'function' && window.useRealtime === true) {
    try {
      // subscribe to a limited snapshot (your DB helper limits by default)
      unsubOrders = window.FirebaseDB.onOrdersSnapshot((orders) => {
        // replace cache with recent snapshot
        ordersCache = orders || [];
        // reset pagination (we show recent only)
        window.nextCursor = null;
        window.allPagesLoaded = false;
        applyFiltersAndRender();
      });
      return;
    } catch (e) {
      console.warn('Realtime subscription failed, falling back to paginated fetch', e);
      // fall-through to pagination
    }
  }

  // default: paginated reads (safe for Spark free)
  await fetchFirstOrdersPage();
}


// ---------- PAGINATION HELPERS (add after startOrdersListener) ----------
window.nextCursor = null;        // doc id cursor (global-ish)
window.allPagesLoaded = false;
let isLoadingOrders = false;
let pageSize = 5;               // adjust 20-100 depending on needs

function ensureLoadMoreButton() {
  if (document.getElementById('loadMoreOrdersBtn')) return;
  const node = document.createElement('div');
  node.style.textAlign = 'center';
  node.style.padding = '12px';
  node.innerHTML = `<button id="loadMoreOrdersBtn" class="btn-small">Load more</button>`;
  ordersList.parentNode.insertBefore(node, ordersList.nextSibling);
  const btn = document.getElementById('loadMoreOrdersBtn');
  btn.addEventListener('click', () => fetchNextOrdersPage());
  // optional: infinite scroll trigger
  if ('IntersectionObserver' in window) {
    const obs = new IntersectionObserver(entries => {
      entries.forEach(ent => {
        if (ent.isIntersecting && !isLoadingOrders && !window.allPagesLoaded) fetchNextOrdersPage();
      });
    }, { root: null, rootMargin: '200px' });
    obs.observe(btn);
  }
}

async function fetchFirstOrdersPage({ limit = pageSize } = {}) {
  ordersCache = [];
  window.nextCursor = null;
  window.allPagesLoaded = false;
  ensureLoadMoreButton();
  return fetchNextOrdersPage({ limit });
}

async function fetchNextOrdersPage({ limit = pageSize } = {}) {
  if (isLoadingOrders || window.allPagesLoaded) return;
  isLoadingOrders = true;
  const btn = document.getElementById('loadMoreOrdersBtn');
  if (btn) { btn.disabled = true; btn.textContent = 'Loadingâ€¦'; }

  try {
    if (!window.FirebaseDB || typeof window.FirebaseDB.listOrdersPage !== 'function') {
  // No paginated helper available â€” avoid expensive full-collection reads on Spark.
  ordersList.innerHTML = '<div style="padding:12px;">Orders not available</div>';
  return;
}

    const res = await window.FirebaseDB.listOrdersPage({ limit, startAfterId: window.nextCursor });
    if (!res || !res.success) { console.warn('listOrdersPage failed', res && res.error); return; }

    const page = res.orders || [];
    ordersCache = ordersCache.concat(page);
    // update cursor and allPagesLoaded flag
    window.nextCursor = res.nextCursor || null;
    if (!window.nextCursor || page.length < limit) window.allPagesLoaded = true;
    applyFiltersAndRender();
  } catch (err) {
    console.error('fetchNextOrdersPage error', err);
  } finally {
    isLoadingOrders = false;
    if (btn) {
      btn.disabled = window.allPagesLoaded;
      btn.textContent = window.allPagesLoaded ? 'All loaded' : 'Load more';
    }
  }
}

// optimistic update helper (update UI immediately, then send remote update)
async function updateOrderStatusOptimistic(orderId, newStatus) {
  const idx = ordersCache.findIndex(x => String(x.id || x.localId || '') === String(orderId));
  const prev = idx !== -1 ? ordersCache[idx].status : null;
  // if (idx !== -1) { ordersCache[idx].status = newStatus; applyFiltersAndRender(); }

  if (idx !== -1 && ordersCache[idx].status === newStatus) {
  return { success: true, skipped: true };
}

  // update localStorage (visitor)
  try {
    const localOrders = JSON.parse(localStorage.getItem('orders') || '[]');
    const li = localOrders.findIndex(lo => String(lo.localId || lo.remoteId || '') === String(orderId) || String(lo.id || '') === String(orderId));
    if (li !== -1) { localOrders[li].status = newStatus; localStorage.setItem('orders', JSON.stringify(localOrders)); }
  } catch(e){}

  if (!window.FirebaseDB || typeof window.FirebaseDB.updateOrderStatus !== 'function') {
    showToast('Saved locally (no server helper)');
    return { success: true, localOnly: true };
  }

  try {
    const res = await window.FirebaseDB.updateOrderStatus(orderId, newStatus);
    if (!res.success && idx !== -1) { ordersCache[idx].status = prev; applyFiltersAndRender(); }
    return res;
  } catch (err) {
    if (idx !== -1) { ordersCache[idx].status = prev; applyFiltersAndRender(); }
    return { success: false, error: err };
  }
}


// MARK PAYMENT (optimistic + remote)
async function updateOrderPaymentOptimistic(orderId, newPaymentStatus) {
  const idx = ordersCache.findIndex(x => String(x.id || x.localId || '') === String(orderId));
  const prev = idx !== -1 ? ordersCache[idx].paymentStatus : null;

  if (idx !== -1 && ordersCache[idx].paymentStatus === newPaymentStatus) {
    return { success: true, skipped: true };
  }

  // optimistic local change
  if (idx !== -1) {
    ordersCache[idx].paymentStatus = newPaymentStatus;
    applyFiltersAndRender();
  }

  // persist to localStorage visitor copy if present
  try {
    const localOrders = JSON.parse(localStorage.getItem('orders') || '[]');
    const li = localOrders.findIndex(lo => String(lo.localId || lo.remoteId || lo.id || '') === String(orderId));
    if (li !== -1) { localOrders[li].paymentStatus = newPaymentStatus; localStorage.setItem('orders', JSON.stringify(localOrders)); }
  } catch(e){}

  if (!window.FirebaseDB || typeof window.FirebaseDB.updateOrderPaymentStatus !== 'function') {
    // fallback success (local-only)
    return { success: true, localOnly: true };
  }

  try {
    const res = await window.FirebaseDB.updateOrderPaymentStatus(orderId, newPaymentStatus);
    if (!res.success && idx !== -1) { ordersCache[idx].paymentStatus = prev; applyFiltersAndRender(); }
    return res;
  } catch (err) {
    if (idx !== -1) { ordersCache[idx].paymentStatus = prev; applyFiltersAndRender(); }
    return { success: false, error: err };
  }
}

// exposed function to confirm payment status (admin)
async function markPaymentWithConfirm(orderId, paymentStatus) {
  if (!window._confirmingPayments) window._confirmingPayments = new Set();
  if (!window._updatingPayments) window._updatingPayments = new Set();

  if (window._confirmingPayments.has(orderId)) {
    showToast('Payment action already in progress for this order', 1400, 'info'); return;
  }
  window._confirmingPayments.add(orderId);

  try {
    const idx = ordersCache.findIndex(x => String(x.id || x.localId || '') === String(orderId));
    const ord = idx !== -1 ? ordersCache[idx] : null;
    const currentPayment = (ord && ord.paymentStatus) ? String(ord.paymentStatus).toLowerCase() : 'pending';
    if (currentPayment === paymentStatus) {
      showToast(`Payment already ${paymentStatus}`, 1400, 'info'); return;
    }
    if (window._updatingPayments.has(orderId)) {
      showToast('Update already running for this order', 1400, 'info'); return;
    }

    const ok = confirm(`Set payment for order ${orderId} to "${paymentStatus}"?`);
    if (!ok) return;

    window._updatingPayments.add(orderId);
    const res = await updateOrderPaymentOptimistic(orderId, paymentStatus);

    if (!res || !res.success) {
      if (res && res.skipped) { showToast('No change needed', 1200, 'info'); return; }
      alert('Failed to update payment status'); return;
    }

    const toastType = paymentStatus === 'paid' ? 'confirmed' : 'info';
    showToast(`Order ${orderId} payment: ${paymentStatus}`, 2000, toastType);

    applyFiltersAndRender();
  } finally {
    window._confirmingPayments.delete(orderId);
    window._updatingPayments.delete(orderId);
  }
}

// --- Location helpers ---
// Admin view: open map modal showing client/delivery positions (uses Google Maps or OpenStreetMap link fallback)
function openMapModalForOrder(order) {
  if (!order) {
    alert('Order not available for map view');
    return;
  }

  // Collect coords with fallbacks
  const clientLoc = order.clientLocation || order.location || (order.locationHintCoords ? order.locationHintCoords : null);
  const deliveryLoc = order.deliveryLocation || null; // expected { lat, lng } from driver

  // Build a simple modal (re-usable)
  let modal = document.getElementById('orderMapModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'orderMapModal';
    modal.className = 'modal-backdrop';
    modal.style.display = 'none';
    modal.innerHTML = `
      <div class="modal" role="dialog" aria-modal="true" style="max-width:900px; width:95%;">
        <div class="modal-header">
          <div><h3>Order Location â€” #<span id="mapModalOrderId"></span></h3><small id="mapModalSubtitle"></small></div>
          <div><button id="closeMapModal" class="btn-small">Close</button></div>
        </div>
        <div class="modal-body" id="mapModalBody" style="padding:8px;">
          <div id="mapFrame" style="height:420px; width:100%; background:#f2f2f2; display:flex; align-items:center; justify-content:center;">Loading mapâ€¦</div>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    document.getElementById('closeMapModal').addEventListener('click', ()=> modal.style.display='none');
    modal.addEventListener('click', (e)=> { if (e.target === modal) modal.style.display = 'none'; });
  }

  document.getElementById('mapModalOrderId').textContent = order.id || order.localId || '';
  const subtitle = `Customer: ${order.visitorName || 'â€”'} â€¢ ${order.phone || 'â€”'} â€¢ Total: $${(order.total||0).toFixed(2)}`;
  document.getElementById('mapModalSubtitle').textContent = subtitle;

  // Build a map link/embed. Prefer Google Maps + markers via URL (works on mobile & desktop).
  // If both points available, we'll show one map link centered between them.
  let latA = clientLoc && clientLoc.lat ? clientLoc.lat : null;
  let lngA = clientLoc && clientLoc.lng ? clientLoc.lng : null;
  let latB = deliveryLoc && deliveryLoc.lat ? deliveryLoc.lat : null;
  let lngB = deliveryLoc && deliveryLoc.lng ? deliveryLoc.lng : null;

  const frame = document.getElementById('mapFrame');
  if (!latA || !lngA) {
    frame.innerHTML = `<div style="padding:20px; text-align:center; color:#666;">Client location not available yet.</div>
      <div style="text-align:center; margin-top:12px;"><button id="requestClientLocationBtn" class="btn-small">Request client location</button></div>`;
    // attach request handler
    setTimeout(()=> {
      const reqBtn = document.getElementById('requestClientLocationBtn');
      if (reqBtn) reqBtn.addEventListener('click', ()=> {
        // visitor will need to call a link or you can instruct them to share location using the app / page.
        alert('Ask the customer to open their order link and press "Share my location".');
      });
    }, 20);
  } else {
    // Compose Google Maps URL with both markers if delivery coords exist
    let mapUrl = '';
    if (latB && lngB) {
      // center between two points (simple mean)
      const centerLat = (parseFloat(latA) + parseFloat(latB))/2;
      const centerLng = (parseFloat(lngA) + parseFloat(lngB))/2;
      // create a maps URL with two markers (Google Maps supports multiple q=lat,lng or markers for Static API - we'll use link with query show both)
      mapUrl = `https://www.google.com/maps/dir/?api=1&origin=${latB},${lngB}&destination=${latA},${lngA}&travelmode=driving`;
    } else {
      // single marker
      mapUrl = `https://www.google.com/maps?q=${latA},${lngA}`;
    }
    frame.innerHTML = `<iframe src="${mapUrl}" style="width:100%; height:100%; border:0;" loading="lazy"></iframe>`;
  }

  modal.style.display = 'flex';
}

// VISITOR: request browser to get current location and send to server and store locally
async function requestAndSendVisitorLocation(orderId) {
  if (!navigator.geolocation) {
    alert('Geolocation not supported by this browser.');
    return null;
  }

  return new Promise((resolve) => {
    navigator.geolocation.getCurrentPosition(async (pos) => {
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;

      // Update localStorage order
      try {
        const localOrders = JSON.parse(localStorage.getItem('orders') || '[]');
        const idx = localOrders.findIndex(lo => String(lo.localId || lo.remoteId || lo.id || '') === String(orderId));
        if (idx !== -1) {
          localOrders[idx].clientLocation = { lat, lng, ts: Date.now() };
          localStorage.setItem('orders', JSON.stringify(localOrders));
        }
      } catch (e) { console.warn('saving visitor loc failed', e); }

      // Send to server if supported
      if (window.FirebaseDB && typeof window.FirebaseDB.updateOrderLocation === 'function') {
        try {
          await window.FirebaseDB.updateOrderLocation(orderId, { lat, lng });
        } catch (e) { console.warn('updateOrderLocation failed', e); }
      }

      // Refresh UI and bells
      showToast('Location shared for delivery', 1600, 'info');
      refreshOrderBell();
      refreshVisitorOrderHistoryUI();

      resolve({ lat, lng });
    }, (err) => {
      console.warn('geolocation error', err);
      alert('Unable to get your location. Please allow location permission and try again.');
      resolve(null);
    }, { enableHighAccuracy: true, timeout: 15000 });
  });
}

// DELIVERY RIDER: start updating delivery location continuously (call on rider app)
function startDeliveryWatcher(orderId) {
  if (!navigator.geolocation) {
    alert('Geolocation not supported');
    return null;
  }
  if (!window.FirebaseDB || typeof window.FirebaseDB.updateDeliveryLocation !== 'function') {
    alert('Delivery update helper not available on server');
    return null;
  }

  const watchId = navigator.geolocation.watchPosition(async (pos) => {
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;
    try {
      await window.FirebaseDB.updateDeliveryLocation(orderId, { lat, lng });
    } catch (e) { console.warn('updateDeliveryLocation failed', e); }
  }, (err) => {
    console.warn('delivery watch error', err);
  }, { enableHighAccuracy: true, maximumAge: 3000, timeout: 10000 });

  return watchId;
}


// optional: enable a limited realtime (admin toggle)
async function enableRealtimeRecent(limit = 10) {
  if (!window.FirebaseDB || typeof window.FirebaseDB.onOrdersSnapshot !== 'function') {
    return alert('Realtime not available');
  }
  // set global flag used in startOrdersListener
  window.useRealtime = true;
  // unsub any paginated listeners if you had
  if (unsubOrders) { try { unsubOrders(); } catch(e){} unsubOrders = null; }
  unsubOrders = window.FirebaseDB.onOrdersSnapshot(list => {
    ordersCache = list || [];
    window.nextCursor = null;
    window.allPagesLoaded = false;
    applyFiltersAndRender();
  }, { limit });
  showToast('Realtime (recent) enabled');
}
function disableRealtime() {
  window.useRealtime = false;
  if (unsubOrders) { try { unsubOrders(); } catch(e){} unsubOrders = null; }
  showToast('Realtime disabled â€” using paginated reads');
  // reload first page
  fetchFirstOrdersPage();
}

// cheap bell refresh (uses loaded pages). For accurate full count use the expensive function below.
async function refreshOrderBellCheap() {
  try {
    const bellCount = document.getElementById('orderBellCount');
    if (!bellCount) return;
    const localPending = (ordersCache || []).filter(o => ((o.status || o.paymentStatus || 'pending') === 'pending')).length;
    bellCount.textContent = localPending;
  } catch(e){ console.warn(e); }
}

// expensive: accurate count for today (warns admin)
async function refreshOrderBellAccurateForToday() {
  if (!confirm('This will read many documents and may cost reads. Continue?')) return;
  try {
    if (typeof window.FirebaseDB.listOrdersSince === 'function') {
      const res = await window.FirebaseDB.listOrdersSince({ fromTimestamp: Math.floor(startOfToday()/1000) });
      if (res && res.success) {
        const pending = (res.orders || []).filter(o => ((o.status || o.paymentStatus || 'pending') === 'pending')).length;
        const bell = document.getElementById('orderBellCount');
        if (bell) bell.textContent = pending;
        showToast('Accurate count loaded');
        return;
      }
    }
    // fallback: page through pages (may be slow/expensive)
    let cursor = null, pending = 0;
    while (true) {
      const r = await window.FirebaseDB.listOrdersPage({ limit: 500, startAfterId: cursor });
      if (!r || !r.success) break;
      const page = r.orders || [];
      page.forEach(o => { if (isInPeriod(o, 'today') && ((o.status || 'pending') === 'pending')) pending++; });
      if (!r.nextCursor || page.length === 0) break;
      cursor = r.nextCursor;
    }
    const bell = document.getElementById('orderBellCount');
    if (bell) bell.textContent = pending;
    showToast('Accurate count loaded (costly)');
  } catch (e) {
    console.error(e);
    alert('Accurate count failed');
  }
}

    // If not signed in, show inline login form
    function showAdminLoginPrompt() {
      ordersList.innerHTML = `
        <div style="padding:20px;">
          <h3>Sign in as Admin</h3>
          <form id="adminSignInForm">
            <div style="margin-bottom:8px;"><input id="adminEmail" placeholder="Email" required></div>
            <div style="margin-bottom:8px;"><input id="adminPass" type="password" placeholder="Password" required></div>
            <div><button type="submit" class="btn-small">Sign in</button></div>
            <p style="font-size:12px; color:#666; margin-top:8px;">Make sure the Firebase Auth user exists and is added in the 'admins' (or 'admin') collection in Firestore.</p>
          </form>
        </div>
      `;
      const form = document.getElementById('adminSignInForm');
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('adminEmail').value.trim();
        const pass = document.getElementById('adminPass').value.trim();
        if (!window.FirebaseDB || !window.FirebaseDB.adminSignIn) { alert('Auth not available'); return; }
        const res = await window.FirebaseDB.adminSignIn(email, pass);
        if (!res.success) {
          alert('Sign in failed: ' + (res.error && res.error.message ? res.error.message : res.error));
          return;
        }
        // success
        currentAdmin = res.adminDoc || { email };
        onAdminSignedIn(currentAdmin);
      });
    }

    // When admin is signed in: show info & start listening to orders
    function onAdminSignedIn(adminDoc) {
      currentAdmin = adminDoc;
      adminInfo.innerHTML = `<strong>${adminDoc.name || adminDoc.email}</strong><br><small>${adminDoc.email}</small>`;
      // start listening (but ensure DB ready)
      startOrdersListener();
    }


    async function deleteOrderCompletely(orderId) {
  if (!window.FirebaseDB || !window.FirebaseDB.deleteOrder) {
    alert('Delete not available');
    return;
  }

  const res = await window.FirebaseDB.deleteOrder(orderId);
  if (res.success) {
    ordersCache = ordersCache.filter(o => o.id !== orderId);
    removeOrderFromLocalStorage(orderId);
    applyFiltersAndRender();
    showToast('Order deleted');
  } else {
    alert('Failed to delete order');
  }
}

    // profile editing & logout
    openProfileBtn.addEventListener('click', async () => {
      if (!currentAdmin || !currentAdmin.id) return alert('No admin info');
      const name = prompt('Admin name', currentAdmin.name || '');
      const phone = prompt('Phone', currentAdmin.phone || '');
      if (name === null) return;
      const res = await window.FirebaseDB.updateAdminProfile(currentAdmin.id, { name, phone });
      if (res.success) {
        alert('Profile updated');
        currentAdmin = { ...currentAdmin, name, phone };
        adminInfo.innerHTML = `<strong>${currentAdmin.name || currentAdmin.email}</strong><br><small>${currentAdmin.email}</small>`;
        try {
          const cached = JSON.parse(localStorage.getItem('adminDoc') || '{}');
          cached.name = name; cached.phone = phone;
          localStorage.setItem('adminDoc', JSON.stringify(cached));
        } catch(e){/*ignore*/}
      } else alert('Failed to update profile');
    });

    adminLogoutBtn.addEventListener('click', async () => {
      const res = await window.FirebaseDB.adminSignOut();
      if (res.success) {
        if (unsubOrders) { try { unsubOrders(); } catch(e){} unsubOrders = null; }
        currentAdmin = null;
        adminInfo.innerHTML = 'Not signed in';
        try { localStorage.removeItem('adminDoc'); localStorage.removeItem('adminSigned'); } catch(e){}
        showAdminLoginPrompt();
      } else {
        alert('Logout failed');
      }
    });

    // On admin page: first try local cache so UI appears fast, then attach real listener
    (function adminPageAuthGuard() {
      try {
        const localDoc = JSON.parse(localStorage.getItem('adminDoc') || 'null');
        if (localDoc && localDoc.email) {
          currentAdmin = localDoc;
          onAdminSignedIn(currentAdmin);
        }
      } catch (e) {
        console.warn('adminPage: local admin rehydrate failed', e);
      }

      (async function waitAndAttachAuth() {
        const dbReady = await (new Promise((r) => {
          const check = () => {
            if (window.FirebaseDB && typeof window.FirebaseDB.onAuthStateChange === 'function') return r(true);
            setTimeout(() => {
              if (window.FirebaseDB && typeof window.FirebaseDB.onAuthStateChange === 'function') return r(true);
              return r(false);
            }, 2000);
          };
          check();
        }));

        if (!dbReady) {
          setTimeout(() => {
            if (!window.FirebaseDB) showAdminLoginPrompt();
          }, 700);
          return;
        }

        window.FirebaseDB.onAuthStateChange((user) => {
          if (!user || !user.adminDoc) {
            try { localStorage.removeItem('adminDoc'); localStorage.removeItem('adminSigned'); } catch(e){}
            window.location.href = 'index.html';
            return;
          }
          currentAdmin = user.adminDoc;
          try { localStorage.setItem('adminDoc', JSON.stringify(currentAdmin)); localStorage.setItem('adminSigned', '1'); } catch(e){}
          onAdminSignedIn(currentAdmin);
        });
      })();
    })();

    // small helper: if orders don't show due to realtime issues, allow refresh button to force fetch
    async function tryFetchOrdersOnce() {
// Prefer safe paginated fetch â€” avoid listAllOrders()
if (!window.FirebaseDB || typeof window.FirebaseDB.listOrdersPage !== 'function') {
  ordersList.innerHTML = '<div style="padding:12px;">Orders not available</div>';
  return;
}
ordersList.innerHTML = '<div style="padding:12px">Loading orders...</div>';
// Use paginated first page (safe)
try {
  await fetchFirstOrdersPage();
} catch (err) {
  console.error('tryFetchOrdersOnce error', err);
  ordersList.innerHTML = '<div style="padding:12px;">Realtime not available</div>';
}

    }

    // Allow admin to click refresh if real-time not available
    refreshBtn.addEventListener('click', async () => {
  // refresh first page (cheap)
  await fetchFirstOrdersPage();
});


    const exportBtn = document.getElementById('exportBtn');
const exportMenu = document.getElementById('exportMenu');

exportBtn.addEventListener('click', () => {
  exportMenu.classList.toggle('hidden');
});

exportMenu.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('click', () => {
    const type = btn.dataset.export;
    const data = getCurrentlyFilteredOrders();
    if (type === 'csv') exportCSV(data);
    if (type === 'pdf') exportPDF(data);
    exportMenu.classList.add('hidden');
  });
});
function getCurrentlyFilteredOrders() {
  const q = (searchInput.value || '').trim().toLowerCase();
  const status = statusFilter.value;
  const period = periodSelect.value || 'today';

  return ordersCache.filter(o => {
    if (!isInPeriod(o, period)) return false;
    if (status !== 'all' && (o.status || 'pending') !== status) return false;
    if (q) {
      const s = `${o.visitorName||''} ${o.phone||''} ${o.id||''} ${o.district||''}`.toLowerCase();
      if (!s.includes(q)) return false;
    }
    return true;
  });
}

function exportCSV(orders) {
  if (!orders.length) return alert('No orders to export');

  const rows = [
    ['Order ID','Name','Phone','District','Status','Total','Date']
  ];

  orders.forEach(o => {
    rows.push([
      o.id,
      o.visitorName || '',
      o.phone || '',
      o.district || '',
      o.status || 'pending',
      o.total || 0,
      new Date(orderTimestampMs(o)).toLocaleString()
    ]);
  });

  const csv = rows.map(r => r.map(v => `"${v}"`).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'orders_export.csv';
  a.click();
}

function exportPDF(orders) {
  if (!orders.length) return alert('No orders to export');

  const win = window.open('', '_blank');
  win.document.write(`
    <h2>Orders Report</h2>
    <table border="1" cellspacing="0" cellpadding="6" width="100%">
      <tr>
        <th>ID</th><th>Name</th><th>Status</th><th>Total</th><th>Date</th>
      </tr>
      ${orders.map(o => `
        <tr>
          <td>${o.id}</td>
          <td>${o.visitorName||''}</td>
          <td>${o.status||'pending'}</td>
          <td>$${(o.total||0).toFixed(2)}</td>
          <td>${new Date(orderTimestampMs(o)).toLocaleString()}</td>
        </tr>
      `).join('')}
    </table>
  `);
  win.document.close();
  win.print();
}

    // wire up filters: period/status/search -> applyFiltersAndRender
    document.addEventListener('DOMContentLoaded', () => {
      // default period is 'today' (already set in HTML)
      periodSelect.value = 'today';
      searchInput.addEventListener('input', () => setTimeout(applyFiltersAndRender, 200));
      statusFilter.addEventListener('change', applyFiltersAndRender);
      periodSelect.addEventListener('change', applyFiltersAndRender);

      // initial attempt to render if orders already present
      if (ordersCache && ordersCache.length) applyFiltersAndRender();
    });

  </script>
</body>
</html>
